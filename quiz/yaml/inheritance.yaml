quiz:
  type: Quiz
  exoname: quiz-inheritance
  max_attempts: 3
  max_grade: 20
  shuffle: false
  questions: inheritance class-attributes


inheritance:
  type: QuizQuestion
  exactly_one_option: yes
  shuffle: yes
  score: [4, -2, 0]
  question: |
    **Héritage**

    ***

    ```python
    class Rectangle:
        def __init__(self, width, height):
            self.width = width
            self.height = height

        def area(self):
            return self.width*self.height

        def perimeter(self):
            return 2.*(self.width+self.height)

        def __repr__(self):
            return f"Rectangle ({self.width}x{self.height})"

    class Square(Rectangle):
        def __init__(self, size):
            super().__init__(size, size)

        def __repr__(self):
            return f"Square ({self.width})"

    sq = Square(2.)
    print(sq.area())
    print(sq)
    ```

    ***

  options:
    - text: |
        Le code précédent renvoie un erreur car la fonction `area` n'est pas définie pour la classe `Square`
      correct: no
      explanation: >
        `area` est héritée de `Rectangle`
    - text: |
        Le code précédent renvoie une erreur dans la méthode `__repr__` de `Square` car l'attribut `width` n'est pas défini pour les instances de la classe `Square`
      correct: no
      explanation: >
        `width` est hérité de `Rectangle`
    - text: |
        Le code s'exécute sans erreur
      correct: yes



class-attributes:
  type: QuizQuestion
  exactly_one_option: no
  shuffle: no
  score: [6, -1, 0]
  question: |
    **Attributs de classe :**


    Considérons le code suivant:

    ***

    ```python
    class Toto:
        names = []
        def __init__(self, name):
            self.names.append(name)

    tata = Toto('tata')
    print(tata.names)
    tutu = Toto('tutu')
    print(tata.names)
    print(tutu.names)
    ```

    ***

    Que se passe-t'il à l'exécution de ce code ?

  explanation: >
    toutes les instances de la classe partagent leur attribut `self.names`,
    qui contient la liste des noms des instances créées jusqu'ici
  options:
    - text: |
        le code produit une erreur car l'attribut names n'est pas initialisé
      correct: no
      explanation: >
        dans le constructeur, `self.names` ne se trouve pas à gauche d'une affectation;
        du coup on est dans la cas d'une **lecture d'attribut**

        qui se fait donc en remontant: objet, classe et super-classes; l'attribut étant
        trouvé dans la classe, il n'y a pas de souci

    - text: |
        le premier print affiche `['tata']`
      correct: yes
      explanation: >

    - text: |
        le premier print affiche `['tata', 'tata']`
      correct: no
    - text: |
        le deuxième print affiche `['tata']`
      correct: no
      explanation: >
        placeholder
    - text: |
        le deuxième print affiche `['tata', 'tutu']`
      correct: yes
      explanation:
        quand on cherche `tutu.names`, on trouve l'attribut dans la classe,
        et il contient donc les noms des instances créées jusqu'ici
    - text: |
        le troisième print affiche `['tutu']`
      correct: no
    - text: |
        le troisième print affiche `['tata', 'tutu']`
      correct: yes
      explanation: >
        les deux instances partagent leur attribut `.name`
